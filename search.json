[{"title":"OTA技术详解","path":"/2025/09/24/OTA技术详解/","content":"导言🧩OTA，即Over-the-Air Technology（空中下载技术），也就是我们常说的无线升级。此前，我曾撰写过相关主题的文章，经过一段时间的思考与沉淀，我对IAP和OTA技术有了更深入的理解与感悟。因此，本文将作为前作的补充，与大家进一步分享我对这些升级技术的新认知。 若文中存在表述错误或不当之处，欢迎各位通过邮件指正。我会及时核查并修正，确保内容的准确性与专业性。 OTA与IAP有什么区别❓IAP即在应用内编程，OTA是空中升级，从升级方式来看可以分为无线与有线。 OTA即空中升级技术，与IAP相比，其显著优势在于无需借助数据线即可完成升级，极大提升了产品升级的便捷性。试想，若一批产品因程序问题出现大规模故障，传统方式往往需要全部返厂重新烧录程序，不仅耗时耗力，还会造成高昂的物流成本与经济损失。而当产品预留OTA升级功能后，就能通过远程推送的方式及时修复问题，大幅降低售后维护成本与潜在损失。 OTA升级流程⬆️这里需要补充流程图为了让大家更直观地理解OTA升级的完整逻辑，我们补充了时序图（也叫序列图）来展示流程。在这个图里，清晰呈现了OTA控制台、OTA服务端与设备端三者之间的交互步骤：从控制台上传升级包、服务端向设备推送升级指令，到设备完成升级包下载与安装，每一个环节的消息传递顺序都一目了然，能帮助大家更清晰地把握OTA升级的全流程协作机制。 核心原理🔥分区管理机制系统至少划分为三个独立分区：Bootloader分区、OTA0分区与OTA1分区。其中，Bootloader作为系统启动核心，承担初始化硬件和引导程序的重任，其内容严禁修改；OTA0与OTA1分区则作为交替使用的升级载体，用于存放待更新的固件版本，确保升级过程的连续性与稳定性。 Flash烧写与校验流程 当升级固件下载至设备RAM后，系统会将其完整写入指定的Flash分区。烧写完成后，立即执行数据校验操作，通过对比烧写代码与原始升级包的哈希值或校验和，确保固件烧写的完整性与准确性，避免因数据丢失或错误导致的升级失败。 无线传输更新机制 更新检测：设备主动与OTA服务端建立通信，通过解析服务端下发的版本校验报文，对比自身当前固件版本。若检测到新版本，即刻触发升级流程。 固件传输：依托蓝牙、Wi-Fi等无线通信技术，设备从服务端下载升级固件，并精准存储至指定的OTA分区，为后续安装更新做好准备。 智能失败回滚策略若OTA升级后的程序出现功能异常、运行崩溃等问题，系统将自动启动回滚机制。以双OTA分区为例，若当前运行分区为OTA1，系统会立即切换至OTA0分区，恢复至前一稳定版本，最大限度降低升级风险，保障设备持续可用。","tags":["嵌入式"]},{"title":"音乐推荐","path":"/2025/06/15/音乐推荐/","content":"私奔这首歌是在我读《我的26岁女房客》时候知道的，这本书是都市情感类的网文小说，引起我的情绪强烈共鸣，非常震撼人心。 倒带这歌太懂失恋的滋味了。它把那些放不下的过去、忘不掉的人，都唱进了歌里，好像在说：明明还爱着，可有些事情就是回不去了，这种遗憾，真的太难受了。","tags":["音乐"],"categories":["心情"]},{"title":"Fast Learner","path":"/2024/12/12/Fast Learner/","content":"最近开发的一个项目用到了一个我完全陌生的技术，我花费了两天时间才勉强将demo移植进项目里，其中还有很多的问题，而和我共同开发的一位老哥也是刚接触这个技术，相比我而言，老哥在使用这个技术显得特别得心应手，我不禁对此感到诧异，于是向老哥提问“为什么你能这么快掌握一个完全模式领域的技术？”老哥的回答是“我是一个Fast Learner”。Fast Learner(快速学习者)，从简单的释义来看就是学习很快的人，我更倾向于这是一项天赋，因为这位老哥是上海交大的博士留学生，所以有一些过人之处是完全合理的。但是这位老哥说可以给我演示一下，我看到这局话的时候我就意识到，这位老哥应该是有特殊的学习办法使他成为了Fast Learner而不是天赋。 What is a Fast Learner?“快速学习”是指使用20%的时间，了解80%的核心概念和逻辑。快速学习，不能完全让你在一个陌生的领域掌握100%的知识点，但是能让你不当100%的麻瓜。 快速学习主要应用于需要跨专业领域去快速了解掌握专业的核心概念和逻辑，在做开发这一领域的同行对此感受应该非常深。技术迭代真的非常快，如果不能通过快速学习去掌握新技术的话，那么淘汰是不可避免的。 How to become a Fast Learner?快速学习的核心，就是用对方法，抓住重点，像“抄近道”一样高效的掌握知识。 先搞懂“为什么学”，再学“是什么”为什么学：我们去学习知识，是因为想要用这些知识去解决一些问题，所以我们学习的目标是解决问题。 普通的学习方法是头看教程，从零基础开始，一点一点学习，这样的学习效率是很低的。 而快速学习，就是理清楚我的目标，为了实现这个目标我要做什么，我要做的这件事用到了哪些知识，然后有选择性的去学习，省略了没用到的无关知识，目标越具体，越能精准的找到学习重点，避免浪费时间在无关内容上。 建立认知模型通过建立认知模型来快速学习，先弄明白实现“目标”的大致步骤，然后通过泛读资料来丰富这个模型，最终模型的就是我们学习的成果。 用“刻意练习”代替“被动输入”快速学习并不是光听光看，而是边学边练，错了马上改正。 总结快速学习明确目标+建立模型+刻意练习，如果可以的话再+一个知识输出。"},{"title":"《嵌入式系统中的神奇魔法——IAP详解》","path":"/2024/12/12/《嵌入式系统中的神奇魔法——IAP详解》/","content":"大家好，我是一名专注于嵌入式领域的知识分享者，在嵌入式系统开发与研究的道路上已经走过了不少年头，积累了丰富的实践经验与理论知识。在当今快速发展的科技时代，嵌入式设备无处不在，从我们日常使用的智能手机、智能家居设备，到工业控制中的复杂系统，乃至汽车的电子控制单元等。而这些设备的软件功能需要不断地优化、升级以适应新的需求、修复潜在漏洞以及提升性能。 在这样的背景下，IAP（In Application Programming，在应用中编程）技术应运而生并扮演着极为关键的角色。它就像是一把神奇的钥匙，开启了嵌入式设备固件更新的便捷之门，无需繁琐的拆卸或专业设备辅助，就能让设备在运行过程中通过预留的通信接口轻松完成固件的更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中，IAP 已然成为了保障设备持续稳定高效运行以及功能不断拓展的核心技术力量，让嵌入式设备能够与时俱进，更好地服务于我们的生活与生产。接下来，就让我们深入探究 IAP 的奥秘。 什么是 IAPIAP（In Application Programming，在应用中编程）是一种嵌入式系统中常用的固件更新技术。它允许用户程序在运行过程中，通过预留的通信接口对设备的固件进行更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中尤为重要。 IAP 的工作原理基本原理 IAP 技术通过将 Flash 存储器划分为两个主要区域来实现固件更新。 Bootloader 区域：包含引导加载程序，负责初始化硬件、设置内存映射，并在需要时加载和更新用户应用程序（User Application）。Bootloader 出厂后通常固定不变，只有在特定条件下（如接收到升级指令）才执行更新操作。 User Application 区域：存放用户的应用程序代码，这部分代码在需要时可以通过 Bootloader 进行更新。 工作流程 设备启动：设备上电后，首先执行 Bootloader 程序。Bootloader 检查是否有升级指令或新固件数据待处理。 固件更新检查：如果检测到有升级需求，Bootloader 通过预留的通信接口接收新固件数据，并将其写入 Flash 的 User Application 区域。 固件验证：写入完成后，Bootloader 进行固件验证，确保数据完整性和正确性。 跳转执行：验证通过后，Bootloader 跳转到 User Application 区域的新固件执行。 关键步骤 Flash 存储器管理：包括擦除扇区、写入数据和校验数据等操作，这些操作通常以块或扇区为单位进行。 数据传输与接收：通过串口、USB 等通信接口接收新固件数据，并存储在 RAM 中，待验证无误后写入 Flash。 安全性与完整性校验：通过加密、签名和校验和等技术确保数据在传输和存储过程中的安全性和完整性。 在 STM32 上实现 IAP 程序STM32 启动流程STM32 在上电或复位后，首先会从内部的 Flash 存储器的起始地址（一般为 0x08000000）读取堆栈指针SP的值，然后加载复位向量，即跳转到复位处理函数。复位处理函数会进行一系列的系统初始化操作，包括时钟系统初始化、中断向量表的设置等。完成这些初始化后，会跳转到用户代码的入口点（通常是 main 函数）开始执行用户应用程序。在 IAP 实现中，了解这个启动流程对于正确划分 Bootloader 和 User Application 区域以及实现跳转执行等操作至关重要。 硬件准备以 STM32F103C8T6 为例，该单片机内置 64KB Flash 和 20KB SRAM。在进行 IAP 设计时，需要合理划分 Bootloader 和 User Application 的区域大小；这里我把 Flash 平均分为两部分，Bootloader 占 32KB，User Application 也占 32KB。 软件实现Bootloader 初始化硬件：对串口、时钟等相关硬件进行初始化设置，确保能正常进行数据通信与后续操作。例如，设置串口的波特率等参数，使能串口接收中断以便及时接收新固件数据。 检查升级指令：持续监听特定的升级指令，如通过串口接收特定的命令字符或数据包头信息来判断是否需要进行固件升级。 接收新固件数据：当检测到升级指令后，通过串口等通信接口按约定的协议接收新固件数据，并将其存储在 RAM 中。需要注意数据接收的完整性和顺序性，可采用数据帧编号、校验和等方式来保证。 写入 Flash：在接收到完整的固件数据并验证无误后，将数据从 RAM 写入到 Flash 的 User Application 区域。写入时要严格按照 Flash 的编程规范操作，先擦除对应扇区（因为 Flash 只能写 0 不能直接写 1，写入前需擦除为 1），再将数据逐字节或逐字写入。同时要处理好 Flash 写入的时序和编程电压等要求，防止写入错误。 跳转至应用程序（User Application）#define APP_FLASH_ADDRESS (0x8008000)typedef void (*pFunction)(void);pFunction Jump_To_Application;uint32_t JumpAddress;void JumpToApp(void) /* 检查是否为有效的栈地址，然后跳转到用户应用程序 */ if (((*(__IO uint32_t*)APP_FLASH_ADDRESS) 0x2FFE0000 ) == 0x20000000) __disable_irq(); /* 跳转到用户应用程序 */ JumpAddress = *(__IO uint32_t*) (APP_FLASH_ADDRESS + 4); Jump_To_Application = (pFunction) JumpAddress; /* 初始化用户应用程序的栈指针 */ __set_MSP(*(__IO uint32_t*) APP_FLASH_ADDRESS); Jump_To_Application(); User Application 配置中断向量表偏移：由于加入了 Bootloader 程序，User Application 的中断向量表位置发生了偏移。需要通过相应的函数来设置中断向量表的偏移量，在 STM32 中可以使用 NVIC_SetVectorTable() 函数。示例代码如下 ：#define FLASH_BASAE 0x08000000#define VECT_TAB_OFFEST 0x8000int main(void) // 修改中断向量 SCB-VTOR = FLASH_BASAE | VECT_TAB_OFFEST; 固件升级流程 设备上电后，Bootloader 首先检查是否有升级指令。 如果有，则通过串口等通信接口接收新固件数据。接收过程中要进行数据校验，如计算校验和并与发送端的校验和对比，确保数据准确无误。 接收完成后，进行固件验证，可采用加密算法验证数据的完整性和合法性，防止恶意固件更新。 验证无误后，跳转到新固件执行。在跳转前要确保系统处于稳定状态，关闭不必要的中断和外设，然后按照 STM32 的跳转指令规范准确地跳转到新固件的入口地址。 结束语这次关于嵌入式系统中 IAP 的分享就到此结束啦！希望通过这篇文章，大家对 IAP 有了较为全面且深入的认识。从它的基本概念到工作原理，从应用案例的展示到在 STM32 上的详细实现步骤，每一个环节都如同拼图的碎片，拼凑出了 IAP 技术的完整画卷。在实际应用中，大家可以依据自身项目需求，灵活运用 IAP 技术，为嵌入式设备打造更强大、更具适应性的固件更新方案。如果在实践过程中遇到任何问题，欢迎随时回顾本文或者查阅更多相关资料深入探索。感谢大家的阅读与关注，期待下一次与大家继续在嵌入式知识的海洋里畅游，共同挖掘更多有趣且实用的技术奥秘！","tags":["嵌入式","STM32"],"categories":["STM32"]},{"title":"想法","path":"/2024/12/12/想法/","content":"新年快乐呀，告别了略带遗憾的2024，来到了充满希望的2025，希望各位小伙伴们都学有所成，事业蒸蒸日上。 在2024我已经立下了一个挑战，就是在2025年保持一整年，每天上传代码等到github仓库上，使热力图全绿，这被我称为“全绿计划”，接下来一整年就努力坚持这个计划，我预计每周汇报一次学习成果，以及项目进度，然后总的记录下来，作为我成长路上的一个见证，同时也锻炼了我的写作水平。 对于2024，我想我应该还不够努力，我想在2025更加努力，我的2024关键词自我总结应该是嵌入式,电赛,C语言吧。 2025.1.2，明天就要出发去嵌入式比赛了，大概三天没有空，需要断更 今天是2025.1.6，说来好笑，明明说全绿计划，结果在新年第三天就开始断了，其实也不然，毕竟很多时候忙起来无法抽身是很常见事情呢，不过我尽量还是保持每日更新吧。 2025.3.14全绿计划崩盘了，个人没有毅力，不过最近尝试作了21年电赛J题，还是挺有难度的，特别是误差要控制在1%。 2025.9.24添加了博客自动部署化流程，测试一下","tags":["随笔","心情"]},{"title":"C语言注释规范","path":"/2023/10/13/C语言注释规范/","content":"C语言代码注释规范函数注释原则函数头部应进行注释，列出：函数的目的功能、输入参数、输出参数、返回值、调用关系（函数、表）等 /********************************************************* Function name ：insert_hhistory* Description : Insert to bd_host_history* Parameter ：* @ipsql SQL statement * @host_level Risk level * @total The total number of risk * @t_id task id* @t_uuid task uuid* @ipaddr target ipaddr * @end_time task end time* Return ：0 --success , other -- fail**********************************************************/int insert_hhistory(char* ipsql,risk host_level,int total,int t_id,char* t_uuid,char* ipaddr,long int end_time) /* * 如果程序过于复杂，这里可以写明，具体算法和思路。 */ 结构体、全局变量的注释int num; /*全局变量的作用*//*结构体的功能*/typedef struct int h; /*High risk*/ int l; /*Low risk*/ int m; /*Middle risk*/ int i; /*Information risk*/risk; 文件头部注释/********************************************************************************* @File name: biu.c* @Author: fanxing* @Version: 1.1* @Date: 2021-3-19* @Description: The function interface。********************************************************************************/ 宏定义/*! CTIMER 最大占空比 可自行修改 */#define CMTER_PWM_MAX 10000 变量注释/// 简述/** 详细描述. */","tags":["C语言"]},{"title":"Git | commit 规范","path":"/2023/10/02/Git commit规范/","content":"Git | commit 规范约定式提交通常要求提交内容包含五个部分 type 类型，用于传达提交的意图 # 主要Typefeat: 增加新功能fix: 修复Bug# 特殊Typedocs: 只改动文档相关内容styles: 不影响代码含义的改动，例如去掉空格，改变所经，增加分号build: 构造工具或外部依赖的改动，例如，webpack，npmrefactor: 代码重构时使用revert: 直行 git revert 打印的 message# 暂不使用Typetest: 增加测试或修改现有测试perf 提高性能的改动ci: 变更 CI 系统配置的更新chore: 不修改 src 或 test 的其余修改，例如构建过程或辅助工具的变动"},{"title":"Termux配置NeoVim保姆级教程","path":"/2022/09/24/Termux配置NeoVim保姆级教程/","content":"教你怎么用 Termux 配置一个优秀的 VimIDE 开始本人是一个专注移动端开发的人(其实是买不起电脑…)，移动端写代码确实没有那么方便，我还为此购买了一个键盘，有了这个键盘，扣代码真的超级爽的，自此我就一发不可收拾了。 但是，有了键盘，却没有一个优秀的编辑器，对于喜欢完美的我，这怎么能行，于是我打开了万能工具Termux。 Termux安装上了vim，可是vim没有配置，没有配置的vim就没有灵魂，本篇博客教你配置自己习惯的Vim Termux 的安装我安装的是Termux，这里我们去 Github 下载Termux，一般下载第一个即可，这里下载的比较慢，可以使用 第三方的 Github 的资源加速下载。 安装好后打开Termux Termux 的配置Termux 换源因为很多软件包的服务器都在国外，所以下载的速度非常缓慢，当然，我们国内也有相应的存放软件包的服务器，这里我们就换到国内的源，这样下载速度就会提升很多了。 这里我们更换中科大的源，把下面的命令粘贴过去回车就好，然后需要确定的时候一路按 y 就好。 sed -i s@^\\(deb.*stable main\\)$@#\\1 deb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main@g $PREFIX/etc/apt/sources.list ; apt update ; apt upgrade ; pkg up NeoVim 的安装这就很简单了，我们只需要在命令行粘贴一下代码就好了 # 安装pkg install neovim -y# 检验 Neovim 是否安装成功nvim -v 如果返回的信息如下所示，则说明 neovim 安装成功 安装成功后就可以进行下一步的配置 Neovim 了 Neovim的配置首先，我们需要创建两个文件夹 # 用于存放插件管理器mkdir ~/.congig/nvim/autoload/ -p# 用于存放下载的插件mkdir ~/.config/nvim/plugged/ -p# 创建 init.vim 配置文件touch ~/.config/nvim/init.vim # 安装 git pkg install git -y# 安装 nodejs pkg install nodejs -y 配置前的准备已经完成，下面开始安装插件管理器 这里我的选择是 vim-plug 作为插件管理器 # 下载 plug.vim 到 ~/.config/nvim/autoload/ 目录中# 如果遇到无法下载的情况可以使用科学上网curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim # 编辑 init.vim 文件nvim ~/.config/nvim/init.vim# --------------分界线---------------# 这里建议先学会 vim 的基础操作再来看# 进入编辑模式 显示行号set nu 黑暗模式set bg=dark 设置Tab宽度为4set shiftwidth=4set tabstop=4 关闭自动换行set nowrapcall plug#begin(~/.config/nvim/plugged) 编辑器主题Plug morhetz/gruvbox 状态栏主题Plug vim-airline/vim-airlinePlug vim-airline/vim-airline-themes 补全插件Plug neoclide/coc.nvim 目录树插件Plug preservim/nerdtree 括号补全插件Plug jiangmiao/auto-pairscall plug#end() 选择使用编辑器的主题autocmd vimenter * nested colorscheme gruvboxset laststatus=2 永远显示状态栏let g:airline_powerline_fonts = 1 支持 powerline 字体let g:airline#extensions#tabline#enabled = 1 显示窗口tab和buffer let g:airline_theme=moloai murmur配色不错if !exists(g:airline_symbols)let g:airline_symbols = endiflet g:airline_left_sep = ▶let g:airline_left_alt_sep = ❯let g:airline_right_sep = ◀let g:airline_right_alt_sep = ❮let g:airline_symbols.linenr = ¶let g:airline_symbols.branch = ⎇ 使用回车确认inoremap silentexpr CR coc#pum#visible() ? coc#pum#confirm() \\: \\C-gu\\CR\\c-r=coc#on_enter()\\CR 插件安装配置就先弄这些了，如后续有需要再自行添加，在上面内容都粘贴上去后，在按下ESC后输入:wq。然后再打开，直接输入:PlugInstall安装插件，这下，插件就安装完成了。 C语言开发环境配置接下来配置最为重要的一步 我们相让编辑器像VSCode那样好用，必定少不了lsp(language-server-protocol)的支持，我们所安装的coc.nvim便是支持lsp，接下来我们安装C语言的插件。 首先，我们需要安装C语言的环境，这里在命令行输入 pkg install clang -y 安装完成后，就在命令行输入nvim，发现此时有报错。 这个报错是一个Bug，我们完全可以通过一系列操作规避他。 首先，安装yarn npm install -g yarn # 进入coc.nvim所在目录cd .config/nvim/plugged/coc.nvim# 安装所需依赖yarn install# 构建yarn build 这些操作结束后，再在命令行输入nvim后就不会再有报错了，就可以安装我们所需的C语言插件了。 在nvim界面，输入:CocInstall coc-clangd，然后回车，安装成功后会显示。这下C语言插件就安装完成了，当然，其他语言的插件安装方法也类似。","tags":["Termux","Nvim"]},{"title":"Termux编译运行SpringBoot","path":"/2022/09/20/Termux编译运行SpringBoot/","content":"使用Termux编译运行SpringBoot的教程 简介有不少的小伙伴因为各种原因没有电脑，到对开发的无限热爱，让他们在移动端也学会了编程，甚至在移动端写代码效率更高，于是，我就来帮助手机上写代码的小伙伴，拓展一下SpringBoot SpringBoot介绍SpringBoot是一个开发基于Spring框架的应用的快速开发框架，它也是SpringCloud构建微服务分布式系统的基础设施。 开始环境准备配置Maven仓库第一次编译结束语 环境准备 Java Maven(目前有这两个就够) Termux直接运行命令安装 pkg install openjdk-17 maven -y 配置Maven仓库默认的仓库地址不仅下载缓慢，甚至部分内容无法下载，所以，我们需要修改Maven仓库的源 首先，找到Maven的配置文件(Termux的默认配置文件相对路径为~..usroptmavenconfsettings.xml) 使用编辑器打开settings.xml 在图片对应位置插入下列内容到此，环境已经配置成功了！ 第一次编译前往spring initializr生成你的SpringBoot项目，把他复制到你的工作目录中 进入你所在的项目，如图所示 shellmvn package 运行命令，首次运行需要下载依赖，其下载时间可能过长，我测试耗时约2min，不同环境网络有可能差异，请耐心等待 编译完成，使用命令让其运作 java -jar target/demo-0.0.1-SNAPSHOT.jar 因为没有编写页面，所以默认访问没有页面，但出现以下页面，说明运行成功 结束语到此，本文章结束，本文略微讲述了使用Termux编译SpringBoot并且在手机上成功运行，极大的帮助了移动端开发的小伙伴。","tags":["Termux","Java","SpringBoot","Spring"]},{"title":"Hello World!","path":"/2022/09/20/hello-world/","content":"Hexo博客终于搭建成功了，纪念一下！"},{"title":"7zip常用命令","path":"/notes/7zip命令行常用命令.html","content":"压缩文件7z a target.zip source 解压文件7z x archive.zip"},{"title":"NodeJS","path":"/notes/NodeJS.html","content":"备忘录npm 官方原始镜像 https://registry.npmjs.org/ 淘宝 NPM 镜像 http://registry.npmmirror.com 阿里云 NPM 镜像 https://npm.aliyun.com 腾讯云 NPM 镜像 https://mirrors.cloud.tencent.com/npm/ 华为云 NPM 镜像 https://mirrors.huaweicloud.com/repository/npm/ 网易 NPM 镜像 https://mirrors.163.com/npm/ 中国科学技术大学开源镜像站 http://mirrors.ustc.edu.cn/ 清华大学开源镜像站 https://mirrors.tuna.tsinghua.edu.cn/"},{"title":"STM32笔记","path":"/notes/STM32笔记.html","content":"Cmake生成Complie_commands.jsoncmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 串口重定向警告 尽量避免使用串口重定向来用`printf`，笔者更建议自己实现`myprintf`，这样可以避免很多坑，减少精力消耗。 GCC#include stdio.hint _write(int fd, char *pBuffer, int size) while (__HAL_UART_GET_FLAG(huart1, UART_FLAG_TC) == 0); HAL_UART_Transmit(huart1, (uint8_t *)pBuffer, size, 0xff); return size; Cmake生成hex bin文件# 添加生成 .hex 和 .bin 文件的自定义命令add_custom_command(TARGET $CMAKE_PROJECT_NAME POST_BUILD COMMAND $CMAKE_OBJCOPY -O ihex $TARGET_FILE:$CMAKE_PROJECT_NAME $CMAKE_BINARY_DIR/$CMAKE_PROJECT_NAME.hex COMMAND $CMAKE_COMMAND -E echo Generating $CMAKE_PROJECT_NAME.hex COMMAND_EXPAND_LISTS COMMAND $CMAKE_OBJCOPY -O binary -S $TARGET_FILE:$CMAKE_PROJECT_NAME $CMAKE_BINARY_DIR/$CMAKE_PROJECT_NAME.bin COMMAND $CMAKE_COMMAND -E echo Generating $CMAKE_PROJECT_NAME.bin COMMAND_EXPAND_LISTS COMMENT Generating hex and bin files VERBATIM) 串口通信数据线硬件注意事项在设计串口相关电路时需要注意： 串口需要接上拉电阻，要么单片机内部上拉，要么外接一个上拉电阻 rx接tx"},{"title":"硬件笔记","path":"/notes/index.html","content":"硬件笔记三极管基级限流电阻计算公式在共发射极电路中，基极限流电阻$R_b$的计算公式为：$$R_b\\frac{V_{in}-V_{be}}{I_b}$$ 参数解释 $V_{in}$：输入到基极回路的电压，为基极电流提供驱动，是外部电源或信号源提供的电压。比如在一个简单的开关电路里，它可能是 5V 的电源电压。 $V_{be}$：基极 - 发射极间的电压降，是三极管的固有参数。硅管的$V_{be}$ 约为 0.7V，锗管约为 0.3V。当基极和发射极间加上此电压，三极管才开始导通。 $I_b$：基极电流，是控制三极管工作状态的关键。改变 $I_b$ 大小，能控制集电极电流 $I_c$ 大小，进而实现信号放大或开关控制。 工作状态影响 截止状态：增大 $R_b$ 使 $I_b$ 减小，当 $V_{be}$ 小于导通电压时，三极管截止，此时 $I_b\\approx0$，$I_c\\approx0$。 放大状态：合适的 $R_b$ 保证 $I_b$ 处于合适范围，让三极管工作在放大区，满足 $I_c \\beta I_b$（$\\beta$ 为电流放大倍数）。 饱和状态：减小 $R_b$ 使 $I_b$ 增大，当 $I_b$ 大到一定程度，三极管进入饱和状态，$I_c$ 不再随 $I_b$ 线性增加。 N型三极管和P型三极管的使用选择当三极管作为开关时，通常N型三极管控制负载的GND端，P型三极管控制VCC端。 下拉电阻和上拉电阻N管加下拉电阻可以有效改善干扰的影响，P管加上拉电阻也是同理"},{"path":"/notes/vim常用操作.html","content":"VIM常用操作常用的操作复制复制光标所在的行如果只在编辑器里复制的话在normal模式下yy就可以复制当前行。 从光标所在位置复制当行首在normal模式下用y0 从光标所在位置复制到行尾在normal模式下用y$ 从光标所在行向上(下)复制n行在norbal模式下用ynj或ynk；例如：向上复制5行，那么就使用y5k，在normal模式下k是光标向上移动，j是光标向下移动。 移动光标"},{"title":"面试笔记","path":"/notes/面试笔记.html","content":"面试笔记STM32 有几个栈单核芯片就只有两个栈，主栈和进程；双核芯片，STM32H750等，双核芯片就有四个任务栈，同样是每个核有一个主栈和一个任务栈。 主栈：用于异常处理和中断服务程序等对实时性要求较高的应用场景，它的优先级较高。 进程栈：用于普通程序的执行流程，如函数调用、局部变量储存等。"}]